<blocks app="Snap! 6, https://snap.berkeley.edu" version="1"><block-definition s="%&apos;thing&apos; put into slot %&apos;slot&apos; of %&apos;target&apos;" type="reporter" category="operators"><comment x="0" y="0" w="90" collapsed="false">Puts a block/value inside a specified input of another block.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%n"></input><input type="%cmdRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>thing</l><l>slot</l><l>target</l></list><l>//if empty&#xD;if (!(target.expression instanceof BlockMorph)) return thing;&#xD;if (!(thing.expression instanceof BlockMorph || thing.expression instanceof ReporterBlockMorph || typeof(thing) == "string" || typeof(thing) == "number" || typeof(thing) == "boolean")) return target;&#xD;&#xD;var type = typeof(thing);&#xD;var slotNum = 1;&#xD;//console.log();&#xD;&#xD;var outExpr = target.expression;  //.fullCopy();&#xD;var outCtx = new Context(undefined, outExpr);&#xD;//outCtx.inputs = thing.inputs || [];&#xD;&#xD;var block;&#xD;&#xD;if (thing.expression instanceof Morph) block = thing.expression;   //.fullCopy();&#xD;&#xD;for (let i in outExpr.children) {&#xD; let child = outExpr.children[i];&#xD;&#xD; if (type == "boolean") {&#xD;  if (child instanceof BooleanSlotMorph) {&#xD;   child.value = thing;&#xD;   return outCtx;&#xD;  }&#xD; } else&#xD; if (child instanceof InputSlotMorph || child instanceof RingMorph || child instanceof CSlotMorph || child instanceof ArgMorph) {&#xD;  if (slotNum == slot) {&#xD;   //console.log(child);&#xD;&#xD;   if (type == "string" || type == "number") {&#xD;    if (!(child.children[0] instanceof InputSlotStringMorph)) return target;&#xD;&#xD;    child.setContents(thing);&#xD;    delete child.bindingID;&#xD;    return outCtx;     &#xD;   }&#xD;&#xD;   if (child instanceof RingMorph) {&#xD;    child.embed(block, thing.inputs);&#xD;&#xD;    return outCtx;&#xD;   } if (child instanceof CSlotMorph) {&#xD;    let input = child;&#xD;&#xD;    //clear children&#xD;    while (input.children[0] !== undefined) input.removeChild(input.children[0]);&#xD;&#xD;    input.children.push(block);&#xD;    block.parent = input;&#xD;    input.fixLayout(); &#xD;   } else {&#xD;    if (child instanceof InputSlotMorph) {&#xD;     thing.expression.isNumeric = child.isNumeric;&#xD;     thing.expression.fixLayout();&#xD;    }&#xD;&#xD;    outExpr.children.splice(i, 1, block);&#xD;    block.parent = outExpr;&#xD;    outExpr.fixLayout();&#xD;   }&#xD;&#xD;   //target.expression.fixLayout();&#xD;   //outCtx.inputs = thing.inputs; &#xD;   return outCtx;&#xD;  }&#xD;&#xD;  slotNum++;&#xD; }&#xD;}&#xD;&#xD;return target; </l></block><list><block var="thing"/><block var="slot"/><block var="target"/></list></block></block></script></block-definition><block-definition s="%&apos;child&apos; put after %&apos;script&apos;" type="reporter" category="operators"><comment x="0" y="0" w="90" collapsed="false">Puts the blocks in the first script at the end of the second script.</comment><header></header><code></code><translations></translations><inputs><input type="%cmdRing"></input><input type="%cmdRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>child</l><l>script</l></list><l>//if empty&#xD;if (!(script.expression instanceof BlockMorph)) return child;&#xD;if (!(child.expression instanceof BlockMorph)) return script;&#xD;&#xD;var tailBlock = script.expression.fullCopy();&#xD;var outCtx = new Context(undefined, tailBlock);&#xD;var lastChild = tailBlock.nextBlock();&#xD;&#xD;while (lastChild instanceof BlockMorph) {&#xD; tailBlock = lastChild;&#xD; lastChild = lastChild.nextBlock();&#xD;}&#xD;&#xD;tailBlock.add(child.expression.fullCopy());&#xD;tailBlock.fixLayout();&#xD;&#xD;//combine inputs&#xD;outCtx.inputs = script.inputs;&#xD;&#xD;for (let v of child.inputs) {&#xD; if (outCtx.inputs.indexOf(v) &lt; 0) {&#xD;  outCtx.inputs.push(v);&#xD; }&#xD;}&#xD;&#xD;return outCtx;</l></block><list><block var="child"/><block var="script"/></list></block></block></script></block-definition><block-definition s="%&apos;val&apos; into first empty slot of %&apos;expr&apos;" type="reporter" category="operators"><comment x="0" y="0" w="90" collapsed="false">Puts an expression/value inside the first empty slot of another command/expression.</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%repRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>val</l><l>expr</l></list><l>if (!(expr.expression instanceof BlockMorph)) return expr;&#xD;&#xD;var isBlock = val.expression instanceof BlockMorph;&#xD;var type = typeof(val);&#xD;var block = null;&#xD;&#xD;if (type == "boolean") {&#xD; //Create true/false boolean block&#xD; //Just copying properties from a boolean block i logged to the dev console&#xD; block = new ReporterBlockMorph();&#xD; block.isPredicate = true;&#xD; block.selector = "reportBoolean";&#xD; block.blockSpec = "%bool";&#xD; block.category = "operators";&#xD; block.color = new Color(98, 194, 19, 1);&#xD;&#xD; let slotMorph = new BooleanSlotMorph();&#xD; slotMorph.color = new Color(98, 194, 19);&#xD; slotMorph.value = val;&#xD; //slotMorph.type = null;&#xD; slotMorph.isStatic = true;&#xD; //slotMorph.isTemplate = false;&#xD; //slotMorph.isFreeForm = false;&#xD;&#xD; slotMorph.fixLayout();&#xD; block.add(slotMorph);&#xD; block.fixLayout();&#xD;} else if (isBlock) {&#xD; block = val.expression.fullCopy();&#xD;}&#xD;&#xD;var outCtx = new Context(undefined, expr.expression);&#xD;&#xD;for (let i in outCtx.expression.children) {&#xD; let input = outCtx.expression.children[i];&#xD;&#xD; //console.log(input);&#xD; &#xD; if (input instanceof RingMorph) { //Ring &#xD;  if (input.children[0].children.length == 0) { //If empty&#xD;   if (isBlock) {&#xD;    input.children[0].add(block);&#xD;    input.children[0].fixLayout();&#xD;&#xD;    return outCtx; &#xD;   }&#xD;  }&#xD; } else if (input instanceof CSlotMorph) {&#xD;  if (input.children[0] === undefined) { //is empty&#xD;  //if (input.isEmptySlot()) {&#xD;   if (isBlock || type == "boolean") {&#xD;    if (block instanceof CommandBlockMorph) {&#xD;     input.add(block);&#xD;     input.fixLayout();&#xD;    } else {&#xD;     outCtx.expression.children.splice(i, 1, block);&#xD;     block.parent = outCtx.expression;&#xD;&#xD;     block.fixLayout();&#xD;    }&#xD;&#xD;    return outCtx;&#xD;   }&#xD;  } &#xD; } else if (input instanceof InputSlotMorph) { //Input slot&#xD;  //if (input.children[0].text == "") { //is empty&#xD;  if (input.isEmptySlot()) {&#xD;   if (type == "string" || type == "number") {&#xD;    input.setContents(val);&#xD;    delete input.bindingID; &#xD;   } else {&#xD;    outCtx.expression.children.splice(i, 1, block);&#xD;    block.parent = outCtx.expression;&#xD;&#xD;    block.fixLayout();&#xD;   }&#xD;&#xD;   return outCtx;&#xD;  }&#xD; } else if (input instanceof BooleanSlotMorph) { //Bool slot&#xD;  if (input.value === null) { //is empty&#xD;   if (type == "boolean") {&#xD;    input.value = val;&#xD;    return outCtx;&#xD;   } else if (isBlock) {&#xD;    outCtx.expression.children.splice(i, 1, block);&#xD;    block.parent = outCtx.expression;&#xD;&#xD;    block.fixLayout(); &#xD;   }&#xD;&#xD;   return outCtx; &#xD;  } &#xD; }&#xD;}&#xD;&#xD;return expr; </l></block><list><block var="val"/><block var="expr"/></list></block></block></script><scripts><comment x="409.00000000000136" y="175.1999999999996" w="241.828125" collapsed="false">RingMorph.children[0].children is empty&#xD;InputSlotMorph.children[0.text == &quot;&quot;&#xD;BooleanSlotMorph.value == null&#xD;CSlotMorph.children is empty</comment></scripts></block-definition><block-definition s="slot %&apos;n&apos; of %&apos;block&apos;" type="reporter" category="operators"><comment x="0" y="0" w="90" collapsed="false">Gets the block/value at the nth slot of a block.</comment><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%repRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>n</l><l>target</l></list><l>//if empty&#xD;if (!(target.expression instanceof BlockMorph)) return new Context();&#xD;&#xD;function get(child) {&#xD;  if (child instanceof BooleanSlotMorph) {&#xD;    return child.value;&#xD;  } else if (child instanceof InputSlotMorph) {&#xD;    return child.children[0].text;&#xD;  } else if (child instanceof CSlotMorph) {&#xD;    var block = child.children[0];&#xD;    //if (block instanceof BlockMorph) block = block.fullCopy();&#xD;&#xD;    return new Context(null, block);&#xD;  } else if (child instanceof RingMorph) {&#xD;    var block = child.children[0].children[0];&#xD;    //if (block instanceof BlockMorph) block = block.fullCopy();&#xD;&#xD;    return new Context(null, block);&#xD;  } else if (child instanceof MultiArgMorph) {&#xD;     var outArr = [];&#xD;&#xD;     for (let j = 0; j &lt; child.children.length - 1; j++) {&#xD;       outArr.push( get(child.children[j]) );&#xD;     }&#xD;&#xD;     return new List(outArr);&#xD;  } else {&#xD;    return new Context(null, child);&#xD;  }&#xD;}&#xD;&#xD;var slotNum = 1;&#xD;for (let i in target.expression.children) {&#xD; let child = target.expression.children[i];&#xD;&#xD; if (child instanceof InputSlotMorph || child instanceof RingMorph || child instanceof CSlotMorph || child instanceof ArgMorph || child instanceof BlockMorph) {&#xD;  if (n === slotNum) {&#xD;   console.log(child);&#xD;&#xD;   return get(child);&#xD;  }&#xD;&#xD;  slotNum++;&#xD; }&#xD;}&#xD;&#xD;return new Context(); </l></block><list><block var="n"/><block var="block"/></list></block></block></script></block-definition><block-definition s="blocks in %&apos;expr&apos;" type="reporter" category="operators"><comment x="0" y="0" w="90" collapsed="false">Reports a list of the blocks in a stack</comment><header></header><code></code><translations></translations><inputs><input type="%cmdRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>expr</l></list><l>var out = [];&#xD;var block = expr.expression;&#xD;&#xD;while (block) {&#xD;  var itm = block.fullCopy();&#xD;  if (itm.nextBlock())  itm.children.pop();&#xD;  out.push( new Context(0, itm) );&#xD;  block = block.nextBlock();&#xD;}&#xD;&#xD;return new List(out);</l></block><list><block var="expr"/></list></block></block></script></block-definition><block-definition s="copy %&apos;obj&apos;" type="reporter" category="other"><comment x="0" y="0" w="90" collapsed="false">Creates a copy of the input</comment><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>obj</l></list><l>if (typeof obj === "object") {&#xD;  if (obj instanceof Context) {&#xD;    var ctx = new Context();&#xD;    ctx.inputs = copy(obj.inputs);&#xD;    if (obj.expression)  ctx.expression = obj.expression.fullCopy();&#xD;    return ctx;&#xD;  }&#xD;&#xD;  return ("fullCopy" in obj) ?&#xD;    obj.fullCopy() : //copy everything, including inputs&#xD;    copy(obj);       //use built-in shallow copy function&#xD;}&#xD;&#xD;return obj; //for primitive types</l></block><list><block var="obj"/></list></block></block></script></block-definition><block-definition s="# of slots in %&apos;expr&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%repRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>expr</l></list><l>return expr.expression.inputs().length;</l></block><list><block var="expr"/></list></block></block></script></block-definition></blocks>